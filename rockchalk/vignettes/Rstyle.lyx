#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass sweavel-article
\begin_preamble
%\VignetteIndexEntry{Rstyle}

\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage{babel}
\usepackage[samesize]{cancel}



\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{figure}

 }{%

   \@float{figure}[#1]%

 }%

 \centering

}{%

 \end@float

}

\renewenvironment{table}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{table}

 }{%

   \@float{table}[#1]%

 }%

 \centering

%  \setlength{\@tempdima}{\abovecaptionskip}%

%  \setlength{\abovecaptionskip}{\belowcaptionskip}%

% \setlength{\belowcaptionskip}{\@tempdima}%

}{%

 \end@float

}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true,style=Rstyle}

% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\scriptsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.90}}



\usepackage{babel}

\usepackage[samesize]{cancel}



\usepackage{ifthen}



\usepackage{listings}% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true, style=Rstyle}
\end_preamble
\options noae
\use_default_options false
\begin_modules
sweave
enumitem
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin9
\fontencoding T1
\font_roman lmodern
\font_sans lmss
\font_typewriter cmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
R Style 
\end_layout

\begin_layout Author
Paul E.
 Johnson <pauljohn @ ku.edu>
\end_layout

\begin_layout Standard
It is an unofficial R style guide, but it is more official in spirit than
 some others.
 I'm trying to understand R style from the perspective of the R Core Development
 team (this is my first effort in Rchaeology
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Which I invented! Definitions:
\end_layout

\begin_layout Description
Rchaeology: The study of R programming by investigation of R source code.
 It is the effort to discern the programming strategies, idioms, and style
 of R programmers in order to better communicate with them.
\end_layout

\begin_layout Description
Rchaeologist: One who practices Rchaeology.
\end_layout

\end_inset

).
 From now on, I'm going to ask people who write R code for my review to
 follow these guidelines.
 It will make their code easier for me to read and it will improve the chances
 that their code will be understandable to members of the R Core Development
 team if the need ever arises to ask for help.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F>>=
\end_layout

\begin_layout Plain Layout

dir.create("plots", showWarnings=T)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=plots/plot,ae=F,height=4,width=6}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, echo=F>>=
\end_layout

\begin_layout Plain Layout

options(width=100, continue="  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE) 
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Style Guides (or the Lack Thereof)
\end_layout

\begin_layout Standard
I have often wished there were a concise, official, comprehensive mandatory
 R style guide, but there isn't.
 The 
\emph on
R Internals
\emph default
 section 
\begin_inset Quotes eld
\end_inset

R coding standards,
\begin_inset Quotes erd
\end_inset

 is quite brief.
 It suggests that indentation should be 4 blank spaces, not much more.
 
\end_layout

\begin_layout Standard
Nature abhors a vacuum, as they say.
 Many others have seen fit to try to fill in the gaps (Google R style guide
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html
\end_layout

\end_inset


\end_layout

\end_inset

; Hadley Wickham's Style Guide
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/hadley/devtools/wiki/Style
\end_layout

\end_inset


\end_layout

\end_inset

).
 In my R group at the University of Kansas, we have sought to do the same.
 
\end_layout

\begin_layout Standard
This writeup attempts to stay as close as possible to the Rchaeological
 evidence, the actual source code of the R Core Development Team.
 I try to lay bare the areas of agreement, the many components of style
 that probably seem so obvious inside R Core that they are barely even worth
 mentioning.
 And I try to explain why there are differing bits of style advice from
 various corners and then use the R source code to try to discern which
 methods are preferred.
 
\end_layout

\begin_layout Section
The Implicit Style Guide: The R Source Code
\end_layout

\begin_layout Standard
Although the official requirements for R code are not stated in all-encompassing
 detail in any document from R Core Development team, there is a generally
 accepted standard for writing R code.
 The experts know what code ought to 
\begin_inset Quotes eld
\end_inset

look like.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
What should your code look like? Stop guessing.
 
\begin_inset Quotes eld
\end_inset

Use the Source, Luke.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Quote
Open the source code for R itself.
 I mean, literally, download R-2.15.2.tar.gz (or whatever is current when you
 read this), and navigate to the directory src/library/stats/R.
 Open the file 
\begin_inset Quotes eld
\end_inset

lm.R
\begin_inset Quotes erd
\end_inset

.
 There's your answer.
\end_layout

\begin_layout Standard
The view is just about the same if you ask R what code it is using to do
 its work.
 Open an R session, run the following commands
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> lm
\end_layout

\begin_layout Plain Layout

> summary.lm
\end_layout

\begin_layout Plain Layout

> stats:::print.summary.lm
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's your answer again.
\end_layout

\begin_layout Standard
Students say 
\begin_inset Quotes eld
\end_inset

my ugly code runs, I don't want to bother with that.
\begin_inset Quotes erd
\end_inset

 That's missing the point.
 With few exceptions, coding style is not about making things 
\begin_inset Quotes eld
\end_inset

work,
\begin_inset Quotes erd
\end_inset

 it is about making them work in a way that is understood by the widest
 possible audience.
 Sometimes ugly code runs, but it is hard to understand, hard to debug.
 
\end_layout

\begin_layout Section
Rchaeological Findings
\end_layout

\begin_layout Standard
From my expertise as an Rchaeologist, I have accumulated a list of bits
 of style advice.
 These proceed in order, from things that every knowledgeable expert will
 accept, to matters of personal taste that are more widely accepted, to
 things that I like, but nobody else does.
 In the remainder, I'm going to try to help the reader sort between my advice
 and the advice of 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 R programmers by assigning subjective probabilities of agreement for each
 of these points.
 If we could draw a random R programmer from the set of programmers that
 I admire, what is the probability that the programmer would agree with
 this advice? Let's call that the 
\begin_inset Quotes eld
\end_inset

Subjective and completely unscientific personal Estimate of Agreement,
\begin_inset Quotes erd
\end_inset

 or SEA.
\end_layout

\begin_layout Subsection
Nearly Universally accepted standards.
\end_layout

\begin_layout Enumerate

\series bold
(SEA 1.0) Indentation of sections is required.

\series default
 This is one of the few guidelines that is explicitly spelled out in the
 R documentation from the core team.
 They discourage the use of the tab key for indentation, instead suggesting
 4 blank spaces.
 Personally, I prefer 2 spaces, and until 2011 that is what I used.
 The documentation provides a brief example of startup code for Emacs so
 that indentions are set correctly at 4 spaces.
 Otherwise, Emacs will provide 2 spaces while editing R files.
 
\end_layout

\begin_layout Enumerate

\series bold
(SEA .98) Blank spaces around symbols are required.

\series default
 Put blank spaces on both sides of assignment symbols, equal signs and mathemati
cal symbols like 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

+
\begin_inset Quotes erd
\end_inset

, and so forth.
 Put one space after commas.
 This is purely a matter of convention and judgment, it does not affect
 the 
\begin_inset Quotes eld
\end_inset

rightness
\begin_inset Quotes erd
\end_inset

 of code.
 But every finished program by a well-qualified programmer will do this.
 While developing code, it sometimes helps me to leave spaces inside parentheses
 and squiggly braces.
 It helps me keep the logic straight.
 The experts never leave those spaces in their final version, however, and
 I try to remember to fix them.
\end_layout

\begin_deeper
\begin_layout Standard
I believe 99.8% of the R programmers that I admire follow those first two
 standards.
 I believe that 95% of my favorites adhere to these principles for the placement
 of squiggly braces.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
(SEA .90) Place squiggly braces (
\begin_inset Quotes eld
\end_inset

{
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

}
\begin_inset Quotes erd
\end_inset

 carefully.

\series default
 This is partly a matter of appearance, but there are some conditions under
 which code will break if the braces are not placed properly.
\end_layout

\begin_deeper
\begin_layout Standard
In R, the opening squiggly braces, 
\begin_inset Quotes eld
\end_inset

{
\begin_inset Quotes erd
\end_inset

 should be at the end of the line of code, rather than at the beginning
 of the next line.
 This is recommended with for and if statements.
 And it is vital in if/else statements.
\end_layout

\begin_layout Standard
In the C language, this is known as the 
\begin_inset Quotes eld
\end_inset

K&R style
\begin_inset Quotes erd
\end_inset

 (named after 
\begin_inset CommandInset citation
LatexCommand citealp
key "kernighan_c_1988"

\end_inset

).
 Here is an example of some code that follows the guideline, and it works.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> x <- 1
\end_layout

\begin_layout Plain Layout

> if (x < 10) {
\end_layout

\begin_layout Plain Layout

  print("hello")
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

  print("goodbye")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

[1] "hello"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Programmers who don't follow this guideline should expect trouble.
 The trouble arrives in two flavors.
\end_layout

\begin_layout Enumerate

\series bold
The unexpected else problem
\series default
.
 Sometimes the 
\begin_inset Quotes eld
\end_inset

else
\begin_inset Quotes erd
\end_inset

 part of an if/else statement will be 
\begin_inset Quotes eld
\end_inset

broken
\begin_inset Quotes erd
\end_inset

 if R does not realize that a command is continuing.
 Try this at the command line.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> if (x < 10) print("hello") 
\end_layout

\begin_layout Plain Layout

[1] "hello" 
\end_layout

\begin_layout Plain Layout

> else print("goodbye") 
\end_layout

\begin_layout Plain Layout

Error: unexpected 'else' in "else"
\end_layout

\end_inset

The else is not understood because it is not tied to the if statement.
 If we keep the braces on a line with the else, the danger is eliminated.
\end_layout

\begin_layout Standard
This is the problem that the help page ?if is referring to when it says,
 
\begin_inset Quotes eld
\end_inset

In particular, you should not have a newline between ‘}’ and ‘else’ to avoid
 a syntax error in entering a ‘if ...
 else’ construct at the keyboard or via ‘source’.
 For that reason, one (somewhat extreme) attitude of defensive programming
 is to always use braces, e.g., for ‘if’ clauses.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
This is a confusing area because sometimes code will work if the else is
 
\begin_inset Quotes eld
\end_inset

out in the open
\begin_inset Quotes erd
\end_inset

 without any squiggly braces nearby.
 For example, when an if/else is wrapped inside a larger structure--say
 a function--then R will correctly interpret else on a line by itself.
 This works
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

myfn <- function(x){
\end_layout

\begin_layout Plain Layout

    if (x < 7)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        print("x is less than 7")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        print("x is excessive")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

myfn(3)
\end_layout

\begin_layout Plain Layout

myfn(88)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The danger, however, is that code in that format cannot be run line-by-line,
 so developing it by running the individual lines will always result in
 failure.
 The else is disconnected from the if, when each individual line is executed
 in R.
 
\end_layout

\begin_layout Standard
As a result, I believe one is well advised to take the defensive approach
 that is mentioned in the help page and write like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x < 7){
\end_layout

\begin_layout Plain Layout

    print("so far, so good")
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

    print("this is the "defensive" style mentioned in the R documents")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
The accidental breakage of else statements
\series default
.
 
\end_layout

\begin_deeper
\begin_layout Standard
It is not necessary to use squiggly braces at all.
 We can write an if/else statement all on one line if we want to.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x < 7) print("so far, so good") else print("this is else")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This would be legal.
 In fact, it is the method in which if and else are documented in ?if.
 
\end_layout

\begin_layout Standard
We can also 
\begin_inset Quotes eld
\end_inset

dangle
\begin_inset Quotes erd
\end_inset

 the else at the end of the if statement, without any squiggly braces.
 R knows that there is more coming on the next line.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x < 7) print("so far, so good") else
\end_layout

\begin_layout Plain Layout

print("this is else")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is some danger in that way of writing.
 Suppose we want to add another command to be performed within the scope
 of the else command.
 Add something on (carelessly):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x < 7) print("so far, so good") else
\end_layout

\begin_layout Plain Layout

print("this is else")
\end_layout

\begin_layout Plain Layout

print("and this other thing if else is true")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's broken.
 But every programmer I know has done it, at least once.
 The first print will run only when else is true, but the second one runs
 all the time.
 This will work properly:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x < 7) print("so far, so good") else{
\end_layout

\begin_layout Plain Layout

    print("this is else")
\end_layout

\begin_layout Plain Layout

    print("and this other thing if else is true")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we forget the squiggly braces, the logic of the situation will not hold
 up.
 Thus, especially while developing and testing code, I insert squiggly braces
 even when they are not required.
 The squiggly braces reduce the chance that I will make a mistake while
 revising this code.
 Perhaps, when a program is done, I'll go back and 
\begin_inset Quotes eld
\end_inset

tighten it up
\begin_inset Quotes erd
\end_inset

 so that I use fewer lines (and won't look so much like a novice).
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection*
Summary of points 1-3
\end_layout

\begin_layout Standard
The advice so far mostly concerns 
\begin_inset Quotes eld
\end_inset

white space
\begin_inset Quotes erd
\end_inset

 in code.
 A programmer's text editor, such as Emacs, will generally have built-in
 functionality to correctly indent sections.
 It may automatically insert spaces.
 It generally will not re-position the squiggly braces for us, however.
\end_layout

\begin_layout Standard
There is a recently introduced R function that can do all three of these
 chores.
 This function, which is called 
\begin_inset Quotes eld
\end_inset

tidy.source
\begin_inset Quotes erd
\end_inset

, is available in the 
\begin_inset Quotes eld
\end_inset

formatR
\begin_inset Quotes erd
\end_inset

 package 
\begin_inset CommandInset citation
LatexCommand citep
key "xie_formatr:_2012"

\end_inset

.
 The style that is followed in formatR is not 
\begin_inset Quotes eld
\end_inset

officially sanctioned,
\begin_inset Quotes erd
\end_inset

 but in my experience, it does very well.
 I've put it to the test with some very ugly tangles of code that students
 have submitted and it works well.
 One of its very useful features is that it scans the input and refuses
 to re-format when there are coding errors.
 This helps in proof-reading student projects.
\end_layout

\begin_layout Standard
The tidy.source function can handle code files, but there is a quick 
\begin_inset Quotes eld
\end_inset

clipboard copy
\begin_inset Quotes erd
\end_inset

 feature.
 Below I've pasted in part of an Emacs session.
 I wrote a badly formatted function myfn, and copied it to the clipboard,
 and then tidy.source() reads the clipboard.
 It seems like magic!.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> myfn <- function(x){ if (x < 7) {i = 77; print(paste("x is less than 7
 but i is", i))} else {print("x is excessive") }} 
\end_layout

\begin_layout Plain Layout

> library(formatR)
\end_layout

\begin_layout Plain Layout

> tidy.source()
\end_layout

\begin_layout Plain Layout

function(x) {
\end_layout

\begin_layout Plain Layout

    if (x < 7) {
\end_layout

\begin_layout Plain Layout

        i = 77
\end_layout

\begin_layout Plain Layout

        print(paste("x is less than 7 but i is", i))
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        print("x is excessive")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
By adding the source parameter, a file name can be provided.
 
\end_layout

\begin_layout Standard
That output is not quite right, in my opinion, because it allows the equal
 sign for assignment of the variable i.
 However, tidy.source has an option to correct that.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> tidy.source(source = "clipboard", replace.assign = TRUE)
\end_layout

\begin_layout Plain Layout

function(x) {
\end_layout

\begin_layout Plain Layout

    if (x < 7) {
\end_layout

\begin_layout Plain Layout

        i <- 77
\end_layout

\begin_layout Plain Layout

        print(paste("x is less than 7 but i is", i))
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        print("x is excessive")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I believe that the style advice to this point will be almost universally
 supported, or at least understood and accepted.
 I don't think anybody could possibly be embarrassed by following those
 standards.
 There is no downside to tidiness! 
\end_layout

\begin_layout Subsection
Widely accepted style advice
\end_layout

\begin_layout Standard
Now we begin to consider some issues that are more subjective.
\end_layout

\begin_layout Enumerate-Resume
How to name functions.
 This is a difficult area because many styles are legal, but some are more
 easily understood.
 The programmer's experience may affect whether code looks 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 or not.
 It is also difficult because R syntax has changed over the years, and some
 things that were illegal are now allowed.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
(.98 SEA) Avoid using names that are already in use, especially common ones.
 Don't write functions named 
\begin_inset Quotes eld
\end_inset

rep
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

lm
\begin_inset Quotes erd
\end_inset

, and so forth.
 Don't do this, even though R (since 2.14) has a graceful mechanism to tolerate
 duplicated names.
 All functions exist within packages, so one could run base::rep to get
 the built-in version of rep, while using rep for a package-specific function.
 Doing that will likely to make code very difficult for the experts to read
 because (almost always) they assume 
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset

 from base.
 Why confuse the R programmers by making a new function 
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset

 that does something different? Pick a new name.
\end_layout

\begin_layout Enumerate
(.65 SEA)Use periods to indicate classes, otherwise don't use periods in
 function names.
 Instead, use camel case to name functions.
 myFunction or getCalculatedValues are better function names than my.thing
 or get.calculated.values.
 A camel cased function may be ugly in the eyes of some, but it will never
 send the reader searching for a class called 
\begin_inset Quotes eld
\end_inset

calculated.values
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

thing
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
This is my opinion, but it is not unanimously shared.
 I bet one-half or two-thirds of the R programmers that I admire would agree.
 As a spot check, consider two of my favorite packages, MASS and car.
 There are not many camel case function names in the MASS package 
\begin_inset CommandInset citation
LatexCommand citep
key "venables_modern_2002"

\end_inset

, which is distributed with R.
 The preferred style in MASS is to give functions brief, all lower case
 letters, such as 
\begin_inset Quotes eld
\end_inset

boxcox.
\begin_inset Quotes erd
\end_inset

 Contrast that with the car package 
\begin_inset CommandInset citation
LatexCommand citep
key "fox_r_2011"

\end_inset

, which is very widely used, which has a similar function called 
\begin_inset Quotes eld
\end_inset

boxCox
\begin_inset Quotes erd
\end_inset

.
 Some time ago, Professor Fox systematically revised car to change the period-st
yle function names to camel case.
 If those two packages are counterbalancing each other in my mind (for and
 against camel case functions), the leading packages for mixed effects models,
 nlme 
\begin_inset CommandInset citation
LatexCommand citep
key "pinheiro_nlme:_2012"

\end_inset

 and lme4 
\begin_inset CommandInset citation
LatexCommand citep
key "bates_lme4:_????"

\end_inset

, weigh in on 
\begin_inset Quotes eld
\end_inset

my side
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Why would a period in a function name be distracting to some readers? Some
 readers are trained in Java or C++.
 In those languages, the period is a 
\begin_inset Quotes eld
\end_inset

connective
\begin_inset Quotes erd
\end_inset

 symbol that can join an object name with its variables or member functions.
 In Java, one would write myThing.x to extract a variable x from an object
 myThing.
 When I read R code, I am still (after 10 years) distracted by periods in
 function names for this reason.
\end_layout

\begin_layout Standard
In R, the period is not used to extract variables, instead we write (in
 S3) myThing$x or (in S4) myThing@x.
 However, in R we do use the period as connective tissue between a generic
 function name and the type of object to which it must be applied.
 The 
\begin_inset Quotes eld
\end_inset

full name
\begin_inset Quotes erd
\end_inset

 of a function will often include a suffix, even though the R interface
 tries to conceal those suffixes from the readers.
 Observe the output from the methods function, which lists the class-specific
 methods, but indicates that they are not exported for easy use.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> methods("confint")
\end_layout

\begin_layout Plain Layout

[1] confint.default confint.glm*    confint.lm*     confint.nls*   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Non-visible functions are asterisked
\end_layout

\begin_layout Plain Layout

> methods("summary")
\end_layout

\begin_layout Plain Layout

 [1] summary.aov             summary.aovlist         summary.aspell*      
  
\end_layout

\begin_layout Plain Layout

 [4] summary.connection      summary.data.frame      summary.Date          
 
\end_layout

\begin_layout Plain Layout

 [7] summary.default         summary.ecdf*           summary.factor       
  
\end_layout

\begin_layout Plain Layout

[10] summary.glm             summary.infl            summary.lm           
  
\end_layout

\begin_layout Plain Layout

[13] summary.loess*          summary.manova          summary.matrix       
  
\end_layout

\begin_layout Plain Layout

[16] summary.mlm             summary.nls*            summary.packageStatus*
 
\end_layout

\begin_layout Plain Layout

[19] summary.PDF_Dictionary* summary.PDF_Stream*     summary.POSIXct      
  
\end_layout

\begin_layout Plain Layout

[22] summary.POSIXlt         summary.ppr*            summary.prcomp*      
  
\end_layout

\begin_layout Plain Layout

[25] summary.princomp*       summary.srcfile         summary.srcref       
  
\end_layout

\begin_layout Plain Layout

[28] summary.stepfun         summary.stl*            summary.table        
  
\end_layout

\begin_layout Plain Layout

[31] summary.tukeysmooth*   
\end_layout

\begin_layout Plain Layout

   Non-visible functions are asterisked
\end_layout

\begin_layout Plain Layout

> methods("predict")
\end_layout

\begin_layout Plain Layout

 [1] predict.ar*                predict.Arima*            
\end_layout

\begin_layout Plain Layout

 [3] predict.arima0*            predict.glm               
\end_layout

\begin_layout Plain Layout

 [5] predict.HoltWinters*       predict.lm                
\end_layout

\begin_layout Plain Layout

 [7] predict.loess*             predict.mlm               
\end_layout

\begin_layout Plain Layout

 [9] predict.nls*               predict.poly              
\end_layout

\begin_layout Plain Layout

[11] predict.ppr*               predict.prcomp*           
\end_layout

\begin_layout Plain Layout

[13] predict.princomp*          predict.smooth.spline*    
\end_layout

\begin_layout Plain Layout

[15] predict.smooth.spline.fit* predict.StructTS*         
\end_layout

\begin_layout Plain Layout

   Non-visible functions are asterisked
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observe that when the user runs 
\begin_inset Quotes eld
\end_inset

confint(myThing)
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

summary(myThing)
\begin_inset Quotes erd
\end_inset

, the R system has to select one particular method with which to get the
 work done.
 R checks for the class of myThing.
 If the class is 
\begin_inset Quotes eld
\end_inset

glm
\begin_inset Quotes erd
\end_inset

, and there is a function confint.glm, summary.glm, or so forth, then those
 specific methods are used to answer the user's request.
 If there is no class-specific method available, then the work is sent to
 confint.default or summary.default.
 
\end_layout

\begin_layout Standard
Many R commands create new objects of particular types that require specialized
 processing.
 The command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m1summ <- summary(m1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
creates a new object from the class 
\begin_inset Quotes eld
\end_inset

summary.lm
\begin_inset Quotes erd
\end_inset

.
 And in order to show that result to the user, the R system uses a function
 called 
\begin_inset Quotes eld
\end_inset

print.summary.lm,
\begin_inset Quotes erd
\end_inset

 but the user would ordinarily not notice that a specialized print function
 exists.
 The same result is produced by these three commands:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m1summ
\end_layout

\begin_layout Plain Layout

print(m1summ)
\end_layout

\begin_layout Plain Layout

stats:::print.summary.lm(m1summ)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first two are equivalent because typing an object's name is always understoo
d as a request for a print function.
 The R design discourages us from using the last approach.
 We are supposed to let the R system select methods to match the classes
 of the objects being processed.
 That's why the print.summary.lm function is not exported from the stats package,
 and thus it is necessary to use the three colons when I want to access
 it directly.
 
\end_layout

\begin_layout Standard
The whole point is that, inside the R system, the periods are not just punctuati
on.
 They may indicate the class type of the object that is being received.
 Thus, I avoid gratuitous periods in function names.
 
\end_layout

\begin_layout Standard
Admittedly, many programmers, especially the ones who are trained in C++,
 find camel cased functions to be very ugly.
 On the other hand, Java and Objective-C programmers are used to them, and
 may even find them attractive.
 But the key point is that periods are distracting.
 
\end_layout

\begin_layout Standard
It seems to me that new functions introduced in R tend to have either camel
 case or underscores for punctuation.
 Run ?get_all_vars.
 That's an eye-opener.
 Some parts of R, especially the old parts, were developed before 
\begin_inset Quotes eld
\end_inset

object oriented
\begin_inset Quotes erd
\end_inset

 programming had come to the forefront and, as a result, they do not comply
 with this advice.
 However, newer functions generally do.
 Observe ?browseVignettes.
 If I knew how to use SVN very well, I'd download the R-devel code and then
 list all functions by the date on which they were introduced.
 I will bet a cup of coffee with anybody that the probability of camel cases
 is higher in the more recent commits.
 I also would bet that the chance of finding a period in a function name
 for purely punctuation reasons is almost zero in the most recent commits.
 Instead of periods, we find either short lower case names, camel case,
 or punctuation with underscores.
 I hasten to admit that the underscores look really strange to me!
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate-Resume

\series bold
How to name variables
\series default
 (and objects and other things you need to keep track of).
\end_layout

\begin_deeper
\begin_layout Enumerate
(1.0 SEA) Officially, R variable names must begin with an alphabetical character
 and must include only letters, numbers and the symbols 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

.
 They must not include 
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

?
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

!
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

&
\begin_inset Quotes erd
\end_inset

 or other special symbols.
 
\end_layout

\begin_layout Enumerate
(1.0 SEA) Never name a variable T or F.
 
\end_layout

\begin_deeper
\begin_layout Standard
This is one thing that almost everybody (99.9%) will agree with.
 NEVER name variables 
\begin_inset Quotes eld
\end_inset

T
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

F
\begin_inset Quotes erd
\end_inset

.
 These are too easily mistaken for TRUE and FALSE values.
 Since R uses TRUE and FALSE as vital elements of almost all commands and
 functions, and since users are allowed to abbreviate those as T or F, a
 horrible confusion can develop if variables are named T or F.
\end_layout

\end_deeper
\begin_layout Enumerate
(.75 SEA) Avoid declaring variables that have the same names as widely used
 functions.
 In 2001, I created a variable 
\begin_inset Quotes eld
\end_inset

rep
\begin_inset Quotes erd
\end_inset

 (for Republican party members) and nothing worked in my program.
 In exasperation, I wrote to the r-help list, and learned that I had obliterated
 R's own function rep with my variable.
 That kind of mistake was common.
 In 2002 or so, the R system was revised so that user-declared variables
 cannot 
\begin_inset Quotes eld
\end_inset

step on
\begin_inset Quotes erd
\end_inset

 R system functions.
 Nevertheless, it is disconcerting to me (probably others) when users create
 variables with names like 
\begin_inset Quotes eld
\end_inset

lm
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

rep
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset

, and so forth.
 Its distracting; its confusing.
\end_layout

\begin_layout Enumerate
(0.40) I avoid underscores in variable names.
 To understand why, please understand the history of S and R.
 At one time, the underscore 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 was used as the assignment symbol.
 That's right, instead of 
\begin_inset Quotes eld
\end_inset

<-
\begin_inset Quotes erd
\end_inset

, we used to write
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y _ x + x^2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The underscore for assignment was allowed, but discouraged, when I started
 using R.
 In those days, R functions that imported data would translate underscores
 into other symbols.
 Underscore for assignment has since been forbidden altogether.
 A while after that, the underscore was allowed in variable and function
 names.
 Because of that history, R veterans may still consider it jarring if your
 variables include underscores.
\end_layout

\end_deeper
\begin_layout Enumerate
(0.40 SEA) Use long names for infrequently used variables.
 If a variable is going to be used twice, we might as well be verbose about
 it.
 
\begin_inset Quotes eld
\end_inset

xlog
\begin_inset Quotes erd
\end_inset

 is better than 
\begin_inset Quotes eld
\end_inset

xl
\begin_inset Quotes erd
\end_inset

, if we are only writing it a few times.
 If we are going to use a name 50 times in a 5 line program, we should choose
 a short one.
 For abbreviations, include a comment to remind the reader what the thing
 stands for.
\end_layout

\begin_layout Enumerate
(0.10 SEA) This is my personal naming scheme, nobody else knows about it,
 unless they have heard about it from me.
 But they might like it if they think it over.
 I suggest we use an alphabetical scheme for naming related things so that
 they always stay together in the workspace.
 As seen by ls(), the related bits should always be together.
 From now on, when I work with a variable named 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

, then all transformations will begin with 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

.
 I will use 
\begin_inset Quotes eld
\end_inset

xlog
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

logx
\begin_inset Quotes erd
\end_inset

 and so forth.
\end_layout

\begin_layout Standard
Example 1.
 Create a numeric variable, recode it as a factor, then create the 
\begin_inset Quotes eld
\end_inset

dummy
\begin_inset Quotes erd
\end_inset

 variables that correspond.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- runif(1000, min = 0, max = 100)
\end_layout

\begin_layout Plain Layout

xf <- cut(x, breaks = c(-1, 20, 50, 80, 101), labels = c("cold", "luke",
 "warm", "hot"))
\end_layout

\begin_layout Plain Layout

xfdummies <- contrasts(xf, contrasts = FALSE )[xf,]
\end_layout

\begin_layout Plain Layout

colnames(xfdummies) <-  paste("xf", c("cold", "luke", "warm", "hot"), sep="")
\end_layout

\begin_layout Plain Layout

rownames(xfdummies) <- names(x)
\end_layout

\begin_layout Plain Layout

dat <- data.frame(x, xf, xfdummies)
\end_layout

\begin_layout Plain Layout

head(dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 2.
 Estimate a regression, calculate the summary, extract summary statistics.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

x1 <- rnorm(200, m = 300, s = 140)
\end_layout

\begin_layout Plain Layout

x2 <- rnorm(200, m = 80, s = 30)
\end_layout

\begin_layout Plain Layout

y <- 3 + 0.2 * x1 + 0.4 * x2 + rnorm(200, s=400)
\end_layout

\begin_layout Plain Layout

dat <- data.frame(x1, x2, y); rm(x1,x2,y)
\end_layout

\begin_layout Plain Layout

m1 <- lm (y ~ x1 + x2, data = dat)
\end_layout

\begin_layout Plain Layout

m1summary <- summary(m1)
\end_layout

\begin_layout Plain Layout

(m1se <- m1summary$sigma)
\end_layout

\begin_layout Plain Layout

(m1rsq <- m1summary$r.squared)
\end_layout

\begin_layout Plain Layout

(m1coef <- m1summary$coef)
\end_layout

\begin_layout Plain Layout

(m1aic <- AIC(m1))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 3.
 Run a regression, collect mean-centered and residual centered variants
 of it, summarize each, and compare them.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ps10, fig=T, include=F, height=5, width=9>>=
\end_layout

\begin_layout Plain Layout

library(rockchalk)
\end_layout

\begin_layout Plain Layout

dat$y2 = with(dat, 3 + 0.02 * x1 + 0.05 * x2 + 2.65 * x1 *x2 + rnorm(200, s=4000))
\end_layout

\begin_layout Plain Layout

par(mfcol=c(1,2))
\end_layout

\begin_layout Plain Layout

m1 <- lm(y2 ~ x1 + x2, data = dat)
\end_layout

\begin_layout Plain Layout

m1i <- lm(y2 ~ x1 * x2, data = dat)
\end_layout

\begin_layout Plain Layout

m1ps <- plotSlopes(m1, plotx = "x1", modx = "x2")
\end_layout

\begin_layout Plain Layout

m1ips <- plotSlopes(m1i, plotx = "x1", modx = "x2")	
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[width=6.5in]{plots/plot-ps10}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<results=tex>>=
\end_layout

\begin_layout Plain Layout

m1imc <- meanCenter(m1i)
\end_layout

\begin_layout Plain Layout

m1irc <- residualCenter(m1i)
\end_layout

\begin_layout Plain Layout

outreg(list(m1, m1i, m1imc, m1irc), tight = TRUE, modelLabels = c("Linear",
 "Interaction", "Mean Centered", "Residual Centered"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "rockchalk"
options "chicago"

\end_inset


\end_layout

\end_body
\end_document
