### Paul Johnson ### Adapted from ideas in post in r-help by Dave Armstrong May 8, 2006


##' Creates a publication quality result table for
##' regression models.
##'
##' This provides "markup" that the user is will copy into a LaTeX
##' document. The table is a LaTeX tabular environment, which can be
##' enclosed in a table to obtain a "floating," automatically numbered
##' LaTeX document environment.  The default now will create the
##' tabular-inside-a-table, but if only the tabular is needed, use the
##' argument float = FALSE. This can be called within Sweave
##' documents. The markup generated by the basic usage will generally
##' be presentable as is, while user requests for additional details
##' may cause output that is slightly messy. Use of the new arguments
##' extraSummary and extraFuns are the main sources of unexpected
##' output, those features are still new. The markup can be hand
##' edited, of course.
##'
##' This was originally designed for models from lm and glm. After
##' rockchalk version >= 1.7.3, the aim was to keep the ease of use for
##' lm and glm, but also incorporate many other kinds of regression. It
##' will work for any kind of regression model that has methods
##' summary(), coef(), vcov() and nobs(). It will try to print some
##' goodness of fit indicators at the bottom of the table; those values
##' are retrieved from the output of summary, which must be an object
##' (as provided by all built-in R regression functions).  If a model's
##' summary() method does not create a suitable named object in the
##' style of R's lm or glm, this is unlikely to be a very nice looking
##' table. Please pressure people who write R packages that claim to
##' "do regressions" to supply methods to do the basic work that we
##' need to compile summaries.
##'
##' A LaTeX tabular object is created, with the floating table
##' markup around it if requested.
##'
##' The regression tables include a minimally sufficient model summary.
##' Some users may want more. New arguments have been allowed so users
##' can ask for that additional information.  For example, lm fits will
##' not generally include output for the "fstatistic," but users can
##' ask for it with extraSummary. I don't, as a matter of habit, add
##' rows for model AIC or BIC. However, if the user's models have AIC
##' and BIC methods, then their output can be integrated.
##'
##' The extraSummary
##' argument simply asks for named elements that exist in the summary
##' object created by the summary function. It does not request new calculations.
##' An example usage might be
##' \code{extraSummary(adj.r.squared = "adj. $R^2", fstatistic = "F")}.
##' The value on the left is the formal name declared by the summary object,
##' while the value on the right is \emph{any} valid LaTeX markup
##' that the user desires to present in the regression table.
##'
##' Some regression models are provided with methods that gather particular
##' information, such as AIC(), BIC(), or logLik().  The extraFuns argument
##' should be a list of function names, in this format:
##' extraFuns = c("AIC", "BIC", "logLik").
##'
##' @param modelList A regression model or an R list of regression
##' models.  If this is a named list, the names will be used as column
##' labels, unless the argument modelLabels is supplied separately,
##' which will override the names of modelList.
##' @param title A title to be displayed on the top of the LaTeX regression
##' table.
##' @param label A string to be used as a LaTeX label in the table to be
##' created.
##' @param modelLabels A vector of charater string variables, one for
##' each element in modelList.
##' @param varLabels To beautify the parameter names printed.  Must be
##' a named vector in the format c(parmname = "displayName", parmname =
##' "displayName"). Include as many parameters as desired, it is not
##' necessary to supply new labels for all of the
##' parameters. "displayName" must be valid laTeX. This feature is
##' useful if your variable names have any illegal LaTeX characters,
##' such as "$" or "_".
##' @param tight If TRUE, parameter estimates and standard errors are
##' printed in a single column.  If FALSE, parameter estimates and
##' standard errors are printed side by side.
##' @param showAIC If TRUE, the AIC estimate is included with the diagnostic values
##' @param float Include boilerplate for a table float, with the tabular
##' markup inside it.
##' @param digits Default = 3. How many digits after decimal sign are to be displayed.
##' @param extraSummary Extra information to be retrieved from the summary(model)
##' and displayed. This must be a vector of named arguments, such as
##' c(adj.r.squared = "adj $R^2$", fstatistic = "F"). The name must be
##' a valid name of the output object, the value should be the label
##' the user wants printed in the table. See details.
##' @export outreg
##' @return None
##' @keywords regression
##' @note There are many R packages that can be used to create LaTeX
##' regression tables. memisc, texreg, apsrtable, xtables, and rms are
##' some. This "outreg" version was in use in our labs before we were
##' aware that those packages were in development. It is not intended
##' as a competitor, it is just a slightly different version of the
##' same that is more suited to our needs.
##' @author Paul E. Johnson \email{<pauljohn@@ku.edu>}
##' @references Citation:
##' @examples
##' x1 <- rnorm(100)
##' x2 <- rnorm(100)
##' y1 <- 5 * rnorm(100) + 3 * x1 + 4 * x2
##' y2 <- rnorm(100) + 5 * x2
##' m1 <- lm(y1 ~ x1)
##' m2 <- lm(y1 ~ x2)
##' m3 <- lm(y1 ~ x1 + x2)
##' gm1 <- glm(y1 ~ x1)

##' outreg(m1, title = "My One Tightly Printed Regression", float = TRUE )

##' outreg(m1, title = "My One Tightly Printed Regression", float = TRUE )

##' outreg(m1, tight = FALSE, modelLabels=c("Fingers"),
##' title = "My Only Spread Out Regressions", float = TRUE)
##'
##' outreg(list(ModelA = m1, "Model B label with Spaces" = m2),
##'        varLabels = list(x1 = "Billie"), title = "My Two Linear Regressions", extraSummary = c(fstatistic = "F"))


##' outreg(list(ModelA = m1, ModelB = m2), modelLabels = c("Overrides ModelA", "Overrides ModelB"),
##' varLabels = list(x1 = "Billie"), title = "Note modelLabels Overrides default names")

##' outreg(list(m1, m2), modelLabels = c("Whatever", "Whichever"),
##' title = "Still have showAIC argument, as in previous versions", showAIC = TRUE,
##' float = TRUE)

##' outreg(list(m1, m2), modelLabels = c("Whatever", "Whichever"),
##' title = "Another way to get AIC output", extraFuns = c("AIC"))
##'
##' outreg(list("Amod" = m1, "Bmod" = m2, "Gmod" = m3), title = "My Three Linear Regressions", float = TRUE)
##'
##' outreg(list(m1, m2, m3), tight = FALSE,
##' modelLabels = c("I Love love love really long titles", "Hate Long", "Medium"),
##' float = TRUE)
##'
##' outreg(list(gm1), modelLabels = c("GLM"), float = TRUE)
##'
##' outreg(list(m1, gm1), modelLabels = c("OLS", "GLM"), float = TRUE)
##'
outreg <-
    function(modelList, title, label, modelLabels = NULL,  varLabels = NULL,
             tight = TRUE, showAIC = FALSE, float = FALSE, digits = 3, extraSummary,
             extraFuns)
{

    gofNames <- c(sigma = "RMSE", r.squared = "$R^2$", deviance = "Deviance",
                  adj.r.squared = "adj $R^2$", fstatistic = "F")

    if (!missing(extraSummary)) gofNames <- c(gofNames, extraSummary)

    ## TESTME: grabs param from object by name, rounds, simplifies
    ## returns text. For getting r.square, adj.r.square, fstatistic.
    harvest <- function(sl, name) {
        res <- vector("character", length = length(sl))
        final <- vector("character", length = length(sl))
        namz <- names(sl)
        names(res) <- namz

        for(i in seq_along(sl)) {
            sli <- sl[[i]]
            y <- sli[[name]]
            if (name == "fstatistic"){
                staty <- paste(format(c(y["value"]), digits = digits),
                               " df(", format(y["numdf"], digits = digits),
                               ",", format(y["dendf"], digits = digits), ")", sep = "")
                y <- staty
            } else if (is.numeric(y)) {
                y <- round(y, digits)
            }
            if (!is.null(y)) res[i] <- y else res[i] <- NA
        }

        if (any(!is.na(res))) nonNull <- TRUE else nonNull <- FALSE
        names(res) <- names(sl)
        attr(res, "nonNull") <- nonNull
        res
    }

    gofRow <- function(x, xname = "fixme") {
        cat(paste(as.character(xname)), sep = "")

        for (mname in names(x)) {

            cat(paste("      &", x[mname]))

            if (tight == FALSE) cat("   &")
        }
        cat("  \\\\\n")
    }


    gofPrint <- function(sl, name){
        y <- harvest(sl, name)
        xname <- ifelse(is.na(gofNames[name]), name, gofNames[name])
        if (attr(y, "nonNull")) {
            gofRow(y, xname)
        }
    }


    ## was input just one model, or a list of models?  ###
    if (inherits(modelList, "lm")) { ##just one model input
        nmodels <- 1
        modelList <- list(modl1 = modelList)
    } else {
        modelList <- modelList
    }

    nmodels <- length(modelList)

    if (is.null(modelLabels)){
        ##Make temporary names
        modelLabels <- paste("M", 1:nmodels, sep ="")
        mln <- names(modelList)
        for (i in seq_along(mln)){
            modelLabels[i] <- mln[i]
        }
    }
    names(modelList) <- modelLabels

    ## Get a regression summary object for each fitted model
    summaryList <- list()
    parmnames <- vector()
    myModelClass <- vector()

    for (i in seq_along(modelList)){
        model <- modelList[[i]]
        summaryList[[i]] <- ssm <- summary(model)
        parmnames <- unique(c(parmnames, names(coef(model))))
        myModelClass[i] <- class(model)[1]
        i <- i+1
    }

    summaryList <- lapply(modelList, function(x) tryCatch(summary(x), error = NULL))

    displayNames <-  as.character(parmnames)
    names(displayNames) <- as.character(parmnames)
    displayNames[names(varLabels)] <- varLabels

    B <- matrix(NA, nrow = length(parmnames), ncol =
                length(modelList), dimnames = list(parmnames))

    dimnames(B)[[2]] <- modelLabels

    for(j in names(modelList)){
        best <- coef(modelList[[j]])
        ##for(i in parmnames) B[i, j] <- CC[i]
        B[parmnames, j] <- best[parmnames]
    }

    SE <- matrix(NA, nrow = length(parmnames), ncol =
                 length(modelList), dimnames = list(parmnames))

    dimnames(SE)[[2]] <- modelLabels

    for(j in names(modelList)){
        seest <- sqrt(diag(vcov(modelList[[j]])))
        SE[parmnames, j] <- seest[parmnames]
    }

    PT <- pt(abs(B/SE), lower.tail = FALSE, df = model$df.residual)

    ##TODO. Look back later to consider generalizing so that we
    ## accept B, SE and PT from coef(summary) if it exists.

    B <- round(B, digits)
    SE <- round(SE, digits)
    SE <- apply(SE, c(1,2), function(x){ paste0("(",x,")") })


    ## If you want a LaTeX table float...
    if (float == TRUE || !missing(title) || !missing(label)){
        cat("\\begin{table}\n")
        if (missing(title)) title <- "A Regression"
        if (missing(label)) label <- "regrlabl"
        cat("\\caption{",title,"}\\label{",label,"}\n")
    }
    cat("\\begin{center}\n")
    nColumns <- ifelse(tight, 1+nmodels, 1 + 2*nmodels)
    cat(paste("\\begin{tabular}{*{",nColumns,"}{l}}\n", sep=""))
    cat("\\hline\n")

    ## Put model labels on top of each model column, if modelLabels were given
    if (!is.null(modelLabels)){
        cat("     ")
        for (modelLabel in modelLabels){
            if (tight == TRUE) {
                cat(paste("&", modelLabel))
            }else{
                cat(paste("&\\multicolumn{2}{c}{",modelLabel,"}",sep=""))
            }
        }
        cat(" \\\\\n")
    }

    ## Print the headers "Estimate" and "(S.E.)", output depends on tight or other format
    if (tight == TRUE){
        cat("               ", rep (" &Estimate ", nmodels), "\\\\\n")
        cat("               ", rep (" &(S.E.) ", nmodels), "\\\\\n")
    } else {
        cat("               ", rep (" &Estimate &(S.E.) ", nmodels), "\\\\\n", fill= FALSE)
    }
    cat("\\hline \n\\hline\n")


    ## Here come the regression coefficients
    for (regname in parmnames){
        cat(paste("", displayNames[regname]), sep="")

        for (model in modelLabels) {
            est <- B[regname, model]
            se <- SE[regname, model]
            if (!is.na(est)) {
                cat(paste("   &   ", est))
                if (abs(PT[regname, model]) < 0.025) cat("*")
                if (tight == FALSE) {
                    cat(paste("   &   ", se,sep=""))
                }
            } else {
                cat("   & . ")
                if (tight == FALSE) cat(" & " )
            }
        }
        cat(" \\\\\n")

        if (tight == TRUE){
            for (model in modelLabels) {
                est <- B[regname, model]
                se <- SE[regname, model]
                if (!is.na(est)) cat(paste("   &  ", se, sep=""))
                else cat("   &  ")
            }
            cat(" \\\\\n")
        }
    }
    cat("\\hline \n")


    ## Print a row for the number of cases
    cat(paste("N"), sep="")
    for (model in modelList) {
        myDF <- nobs(model)
        cat(paste("   &   ", myDF))
        if (tight == FALSE) cat("    &")
    }
    cat(" \\\\\n")

    ## Print a row for the root mean square error
    ## The old way
    ## if ("lm" %in% myModelClass) {
    ##     cat(paste("$RMSE$"),sep="")
    ##     for (model in summaryList) {
    ##         cat( paste("       &", if(is.numeric(model$sigma)) round(model$sigma, digits)))
    ##         if (tight == FALSE) cat("    &")
    ##     }
    ##     cat("  \\\\\n")
    ## }

    ## The new way
    gofPrint(summaryList, "sigma")

    ## Print a row for the R-square
    ## Replace old way:
    ## if ("lm" %in% myModelClass) {
    ##     cat(paste("$R^2$"), sep="")
    ##     for (model in summaryList) {
    ##         cat( paste("       &", if(is.numeric(model$r.square))round(model$r.square, digits)))
    ##         if (tight == FALSE) cat("    &")
    ##     }
    ##     cat("  \\\\\n")
    ## }
    ## The new way
    gofPrint(summaryList, "r.squared")

    ##"adj.r.squared" if there is more than 1 predictor

    ## Print a row for the adj-R-square
    if (length(parmnames) > 2) {
        gofPrint(summaryList, "adj.r.squared")
    }


    if (!missing(extraSummary)){
        for (extra in names(extraSummary)){
            gofPrint(summaryList, extra)
        }
    }

    ## cat(paste("adj $R^2$"), sep="")
    ## for (model in summaryList) {
    ##     cat( paste("       &", if(is.numeric(model$adj.r.square))round(model$adj.r.square, digits)))
    ##     if (tight == FALSE) cat("    &")
    ## }
    ## cat("  \\\\\n")

    ## Print a row for the model residual deviance
    if ("glm" %in% myModelClass) {
        gofPrint(summaryList, "deviance")
    }
    ## Not the old way
    ## if ("glm" %in% myModelClass) {
    ##     cat(paste("$Deviance$"),sep="")
    ##     for (model in summaryList) {
    ##         cat(paste("      &", if(is.numeric(model$deviance))round(model$deviance, digits)))
    ##         if (tight == FALSE) cat("      &")
    ##     }
    ##     cat("  \\\\\n")
    ## }

    ## Print a row for the model's fit, as -2LLR
    if ("glm" %in% myModelClass) {
        cat(paste("$-2LLR (Model \\chi^2)$"),sep="")
        for (model in modelList) {
            if (is.numeric(model$deviance)){
                n2llr <- model$null.deviance - model$deviance
                cat(paste("      &", round(n2llr, digits)))
                gmdf <- model$df.null - model$df.residual + 1

                if (pchisq(n2llr, df = gmdf, lower.tail = FALSE) < 0.05) {cat("*")}
            } else {
                cat("    &")
            }
            if (tight == FALSE) cat("     &")
        }
        cat("  \\\\\n")
    }

    ## Print a row for the model's fit, as -2 LLR
    ## Can't remember why I was multiplying by -2

    if (showAIC == TRUE) {
        cat(paste("$AIC$"),sep="")
        for (model in modelList) {
            cat(paste("      &", if(is.numeric(AIC(model)))round(AIC(model), digits)))
            if (tight == FALSE) cat("      &")
        }
        cat("  \\\\\n")
    }

    ## TODO: round the following output
    if (!missing(extraFuns)){

        elist <- vector("list", length = length(extraFuns))
        for (i in 1:length(extraFuns)){
            myfn <- extraFuns[i]
            if (myfn == "logLik") {
                myresult <- lapply(modelList, function(x) {
                    y <- do.call(myfn, list(x))
                    fstaty <- paste(format(c(y), digits = digits), collapse = ", ",
                                        " (df=", format(attr(y, "df")), ")", sep = "")
                    invisible(fstaty)
                })
                elist[[i]] <- myresult
            } else {
                elist[[i]] <- lapply(modelList, function(x) do.call(myfn, list(x)))
            }
        }
        names(elist) <- extraFuns

        for(i in 1:length(extraFuns)){
            gofRow(elist[[i]], extraFuns[i])
        }
    }

    cat("\\hline\\hline\n")
    cat("* $p \\le 0.05$\n")
    cat("\\end{tabular}\n")
    cat("\\end{center}\n")
    if (float == TRUE || !missing(title) || !missing(label)){
        cat("\\end{table}\n")
    }

}


