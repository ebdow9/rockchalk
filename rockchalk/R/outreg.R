### Paul Johnson ### Adapted from ideas in post in r-help by Dave Armstrong May 8, 2006


##' Creates a publication quality result table for
##' regression models.
##'
##' This provides "markup" that the user is will copy into a LaTeX
##' document. The table is a LaTeX tabular environment, which can be
##' enclosed in a table to obtain a "floating," automatically numbered
##' LaTeX document environment.  The default will create the
##' tabular-inside-a-table, but if only the tabular is needed, use the
##' argument float = FALSE. This can be called within Sweave
##' documents. The markup generated by the basic usage will generally
##' be presentable as is, while user requests for additional details
##' may cause output that needs some hand-editing.
##'
##' A LaTeX tabular object is created, with the floating table
##' markup around it if requested (float = TRUE).
##'
##' The table include a minimally sufficient (in my opinion) model
##' summary.  For any fitted model, \code{outreg()} will present the parameter
##' estimates and standard errors, and it will also scan the summary
##' of the object for some summary values and goodness of fit
##' indicators.  Some users may want more information. lm fits will not
##' include output for the "fstatistic" that is reported in the lm's
##' summary object, but users can ask for it with the argument
##' \code{request}. Similarly, the argument \code{runFuns} can ask for
##' additional diagnostic functions to be reported.
##'
##' While \code{outreg()} originally designed for models fitted by
##' \code{lm()} and \code{glm()}, it will now work for any kind of
##' regression model that has methods \code{summary()}, \code{coef()},
##' \code{vcov()} and \code{nobs()}.  This will not succeed, however,
##' if the regression model's summary function does not create an
##' object that holds values in a workable structure (in the same way
##' that \code{lm()} and \code{glm()} do). Please pressure people who
##' write R packages that claim to "do regression" to supply methods
##' to do the basic work that we need to compile tables.
##'
##' Two types of customization arguments were introduced with
##' rockchalk version 1.7.3.  The new arguments are \code{request} and
##' \code{runFuns}. Beta test reports are welcome!
##'
##' The \code{request} argument supplies a list of names of summary
##' output elements that are desired. The format is a pair, a value to
##' be retrieved and a name to be printed for it. With the \code{lm()}
##' regression, for example, one might want the output of the F test
##' and the adjusted R-square.  An example usage might be
##' \code{request = c(adj.r.squared = "adj. $R^2", fstatistic = "F")}.
##' The names may be included in quotation marks if the user desires
##' to do so: \code{request = c("adj.r.squared" = "adj. $R^2",
##' "fstatistic" = "F")}.  The value on the left is the name of the
##' desired information in the summary object, while the value on the
##' right is \emph{any} valid LaTeX markup that the user desires to
##' display in the first column of the table.  \code{request} terms
##' that generate a single numerical value will generally work fine,
##' while requests that ask for more structured information, such as
##' the F test (including the 2 degrees of freedom values) are still a
##' work in progress.
##'
##' The \code{runFuns} argument is inspired by a user request: could
##' this include the BIC or other summaries that some models report?
##' We have to run the BIC function, and divert the result into the
##' correct column of the result table. Any R function, whether supplied with and R package or in the user's own code, may be used. This is a two-part specification, one representing the function to be run, the other representing the name that is desired in the output. For example, it might be \code{runFuns = c("AIC" = "Akaike Criterion", "BIC" = "Schwartz Criterion", "logLik" = "LL")}.
##'
##' @param modelList A regression model or an R list of regression
##' models.  If this is a named list, the names will be used as column
##' labels, unless the argument modelLabels is supplied separately,
##' which will override the names of modelList.
##' @param title A title to be displayed on the top of the LaTeX regression
##' table.
##' @param label A string to be used as a LaTeX label in the table to be
##' created.
##' @param modelLabels A vector of charater string variables, one for
##' each element in modelList. Will override the names in modelList.
##' @param varLabels To beautify the parameter names printed.  Must be
##' a named vector in the format c(parmname = "displayName", parmname =
##' "displayName"). Include as many parameters as desired, it is not
##' necessary to supply new labels for all of the
##' parameters. "displayName" must be valid laTeX. This feature is
##' useful if your variable names have any illegal LaTeX characters,
##' such as "$" or "_".
##' @param tight If TRUE, parameter estimates and standard errors are
##' printed in a single column.  If FALSE, parameter estimates and
##' standard errors are printed side by side.
##' @param showAIC If TRUE, the AIC estimate is included with the diagnostic values
##' @param float Include boilerplate for a table float, with the tabular
##' markup inside it.
##' @param request Extra information to be retrieved from the summary(model)
##' and displayed. This must be a vector of named arguments, such as
##' c(adj.r.squared = "adj $R^2$", fstatistic = "F"). The name must be
##' a valid name of the output object, the value should be the label
##' the user wants printed in the table. See details.
##' @param runFuns A list of functions
##' @param digits Default = 3. How many digits after decimal sign are to be displayed.
##' @param alpha Default = 0.05.
##' @export outreg
##' @return None
##' @keywords regression
##' @note There are many R packages that can be used to create LaTeX
##' regression tables. memisc, texreg, apsrtable, xtables, and rms are
##' some. This "outreg" version was in use in our labs before we were
##' aware that those packages were in development. It is not intended
##' as a competitor, it is just a slightly different version of the
##' same that is more suited to our needs.
##' @author Paul E. Johnson \email{<pauljohn@@ku.edu>}
##' @examples
##' set.seed(2134234)
##' dat <- data.frame(x1 = rnorm(100), x2 = rnorm(100))
##' dat$y1 <- 30 + 5 * rnorm(100) + 3 * dat$x1 + 4 * dat$x2
##' dat$y2 <- rnorm(100) + 5 * dat$x2
##' m1 <- lm(y1 ~ x1, data = dat)
##' m2 <- lm(y1 ~ x2, data = dat)
##' m3 <- lm(y1 ~ x1 + x2, data = dat)
##' gm1 <- glm(y1 ~ x1, family = Gamma, data = dat)
##' outreg(m1, title = "My One Tightly Printed Regression", float = TRUE )

##' outreg(m1, title = "My One Tightly Printed Regression", float = TRUE )

##' outreg(m1, tight = FALSE, modelLabels=c("Fingers"),
##' title = "My Only Spread Out Regressions", float = TRUE)
##'
##' outreg(list(ModelA = m1, "Model B label with Spaces" = m2),
##'        varLabels = list(x1 = "Billie"), title = "My Two Linear Regressions", request = c(fstatistic = "F"))
##'
##' outreg(list(ModelA = m1, ModelB = m2), modelLabels = c("Overrides ModelA", "Overrides ModelB"),
##' varLabels = list(x1 = "Billie"), title = "Note modelLabels Overrides model names")
##'
##' outreg(list(m1, m2), modelLabels = c("Whatever", "Whichever"),
##' title = "Still have showAIC argument, as in previous versions",
##' showAIC = TRUE, float = TRUE)
##'
##' outreg(list(m1, m2), modelLabels = c("Whatever", "Whichever"),
##' title = "Another way to get AIC output", runFuns = c("AIC" = "Akaike IC"))
##'
##' outreg(list("Amod" = m1, "Bmod" = m2, "Gmod" = m3), title = "My Three Linear Regressions", float = FALSE)
##'
##' outreg(list(m1, m2, m3), tight = FALSE,
##' modelLabels = c("I Love really long titles", "Hate Long", "Medium"),
##' float = FALSE)
##'
##' outreg(list(gm1), modelLabels = c("GLM"), float = TRUE)
##'
##' outreg(list(m1, gm1), modelLabels = c("OLS", "GLM"), float = TRUE)
##'
##' outreg(list(OLS = m1, GLM = gm1), float = TRUE, request = c(fstatistic = "F"), runFuns = c("BIC" = "BIC"))
##'
##' outreg(list(OLS = m1, GLM = gm1), float = TRUE, request = c(fstatistic = "F"), runFuns = c("BIC" = "BIC"), digits = 5, alpha = 0.01)
##'
##' outreg(list(ModelA = gm1, "Model B label with Spaces" = m2), request = c(fstatistic = "F"), runFuns = c("BIC" = "Schwarz IC", "AIC" = "Akaike IC", "nobs" = "N Again?"))
##'
outreg <-
    function(modelList, title, label, modelLabels = NULL,  varLabels = NULL,
             tight = TRUE, showAIC = FALSE, float = FALSE, request,
             runFuns, digits = 3, alpha = 0.05)
{

    gofNames <- c(sigma = "RMSE", r.squared = "$R^2$", deviance = "Deviance",
                  adj.r.squared = "adj $R^2$", fstatistic = "F")

    if (!missing(request)) gofNames <- c(gofNames, request)

    ## TESTME: grabs param from object by name, rounds, simplifies
    ## returns text. For getting r.square, adj.r.square, fstatistic.
    harvest <- function(sl, name) {
        res <- vector("character", length = length(sl))
        namz <- names(sl)
        names(res) <- namz

        for(i in seq_along(sl)) {
            sli <- sl[[i]]
            y <- sli[[name]]
            if (!is.null(y) && name == "fstatistic"){
                staty <- paste(format(c(y["value"]), digits = digits),
                               " df(", format(y["numdf"], digits = digits),
                               ",", format(y["dendf"], digits = digits), ")", sep = "")
                y <- staty
            } else if (is.numeric(y)) {
                y <- round(y, digits)
            }
            if (!is.null(y)) res[i] <- y else res[i] <- ""
        }

        if (any(!is.na(res))) nonNull <- TRUE else nonNull <- FALSE
        names(res) <- names(sl)
        attr(res, "nonNull") <- nonNull
        res
    }

    gofRow <- function(x, xname = "fixme") {
        cat(paste(as.character(xname)), sep = "")

        for (mname in names(x)) {

            cat(paste("      &", x[mname]))

            if (tight == FALSE) cat("   &")
        }
        cat("  \\\\\n")
    }


    gofPrint <- function(sl, name){
        y <- harvest(sl, name)
        xname <- ifelse(is.na(gofNames[name]), name, gofNames[name])
        if (attr(y, "nonNull")) {
            gofRow(y, xname)
        }
    }


    ## was input just one model, or a list of models?  ###
    if (inherits(modelList, "lm")) { ##just one model input
        nmodels <- 1
        modelList <- list(modl1 = modelList)
    } else {
        modelList <- modelList
    }

    nmodels <- length(modelList)

    if (is.null(modelLabels)){
        ##Make temporary names
        modelLabels <- paste("M", 1:nmodels, sep ="")
        mln <- names(modelList)
        for (i in seq_along(mln)){
            modelLabels[i] <- mln[i]
        }
    }
    names(modelList) <- modelLabels

    ## Get a regression summary object for each fitted model
    summaryList <- list()
    parmnames <- vector()
    myModelClass <- vector()

    for (i in seq_along(modelList)){
        model <- modelList[[i]]
        summaryList[[i]] <- ssm <- summary(model)
        parmnames <- unique(c(parmnames, names(coef(model))))
        myModelClass[i] <- class(model)[1]
        i <- i+1
    }

    summaryList <- lapply(modelList, function(x) tryCatch(summary(x), error = NULL))

    displayNames <-  as.character(parmnames)
    names(displayNames) <- as.character(parmnames)
    displayNames[names(varLabels)] <- varLabels

    B <- matrix(NA, nrow = length(parmnames), ncol =
                length(modelList), dimnames = list(parmnames))

    dimnames(B)[[2]] <- modelLabels

    SE <- matrix(NA, nrow = length(parmnames), ncol =
                 length(modelList), dimnames = list(parmnames))
    dimnames(SE)[[2]] <- modelLabels
    DF <- vector("numeric", length = nmodels)

    for(j in seq_along(modelList)){
        modl <- modelList[[j]]
        best <- coef(modl)
        B[parmnames, modelLabels[j]] <- best[parmnames]
        DF[j] <- modl$df.residual
        SE[parmnames, modelLabels[j]] <- sqrt(diag(vcov(modl)))[parmnames]
    }

    sigtest <- function(B, SE, DF) {
        PT <- matrix(NA, nrow = NROW(B), ncol =
                     NCOL(B), dimnames = dimnames(B))
        for (j in seq_along(DF)){
            PT[ ,j] <-  pt((B/SE)[ ,j], lower.tail = FALSE, df = DF[j]) *2
        }
        PT
    }

    PT <- sigtest(B, SE, DF)
    ##TODO. Look back later to consider generalizing so that we
    ## accept B, SE and PT from coef(summary) if it exists.
    B <- round(B, digits)
    SE <- round(SE, digits)
    SE <- apply(SE, c(1,2), function(x){ paste0("(",x,")") })


    ## If you want a LaTeX table float...
    if (float == TRUE || !missing(title) || !missing(label)){
        cat("\\begin{table}\n")
        if (missing(title)) title <- "A Regression"
        if (missing(label)) label <- "regrlabl"
        cat("\\caption{",title,"}\\label{",label,"}\n")
    }
    cat("\\begin{center}\n")
    nColumns <- ifelse(tight, 1+nmodels, 1 + 2*nmodels)
    cat(paste("\\begin{tabular}{*{",nColumns,"}{l}}\n", sep=""))
    cat("\\hline\n")

    ## Put model labels on top of each model column, if modelLabels were given
    if (!is.null(modelLabels)){
        cat("     ")
        for (modelLabel in modelLabels){
            if (tight == TRUE) {
                cat(paste("&", modelLabel))
            }else{
                cat(paste("&\\multicolumn{2}{c}{",modelLabel,"}",sep=""))
            }
        }
        cat(" \\\\\n")
    }

    ## Print the headers "Estimate" and "(S.E.)", output depends on tight or other format
    if (tight == TRUE){
        cat("               ", rep (" &Estimate ", nmodels), "\\\\\n")
        cat("               ", rep (" &(S.E.) ", nmodels), "\\\\\n")
    } else {
        cat("               ", rep (" &Estimate &(S.E.) ", nmodels), "\\\\\n", fill= FALSE)
    }
    cat("\\hline \n\\hline\n")


    ## Here come the regression coefficients
    for (regname in parmnames){
        cat(paste("", displayNames[regname]), sep="")

        for (model in modelLabels) {
            est <- B[regname, model]
            se <- SE[regname, model]
            if (!is.na(est)) {
                cat(paste("   &   ", est))
                if (abs(PT[regname, model]) < (alpha/2)) cat("*")
                if (tight == FALSE) {
                    cat(paste("   &   ", se,sep=""))
                }
            } else {
                cat("   & . ")
                if (tight == FALSE) cat(" & " )
            }
        }
        cat(" \\\\\n")

        if (tight == TRUE){
            for (model in modelLabels) {
                est <- B[regname, model]
                se <- SE[regname, model]
                if (!is.na(est)) cat(paste("   &  ", se, sep=""))
                else cat("   &  ")
            }
            cat(" \\\\\n")
        }
    }
    cat("\\hline \n")


    ## Print a row for the number of cases
    cat(paste("N"), sep="")
    for (model in modelList) {
        myN <- nobs(model)
        cat(paste("   &   ", myN))
        if (tight == FALSE) cat("    &")
    }
    cat(" \\\\\n")

    ## The new way
    gofPrint(summaryList, "sigma")

    ## The new way
    gofPrint(summaryList, "r.squared")

    ##"adj.r.squared" if there is more than 1 predictor

    ## Print a row for the adj-R-square
    if (length(parmnames) > 2) {
        gofPrint(summaryList, "adj.r.squared")
    }


    if (!missing(request)){
        for (extra in names(request)){
            gofPrint(summaryList, extra)
        }
    }

    ## cat(paste("adj $R^2$"), sep="")
    ## for (model in summaryList) {
    ##     cat( paste("       &", if(is.numeric(model$adj.r.square))round(model$adj.r.square, digits)))
    ##     if (tight == FALSE) cat("    &")
    ## }
    ## cat("  \\\\\n")

    ## Print a row for the model residual deviance
    if ("glm" %in% myModelClass) {
        gofPrint(summaryList, "deviance")
    }
    ## Not the old way
    ## if ("glm" %in% myModelClass) {
    ##     cat(paste("$Deviance$"),sep="")
    ##     for (model in summaryList) {
    ##         cat(paste("      &", if(is.numeric(model$deviance))round(model$deviance, digits)))
    ##         if (tight == FALSE) cat("      &")
    ##     }
    ##     cat("  \\\\\n")
    ## }

    ## Print a row for the model's fit, as -2LLR
    if ("glm" %in% myModelClass) {
        cat(paste("$-2LLR (Model \\chi^2)$"),sep="")
        for (model in modelList) {
            if (is.numeric(model$deviance)){
                n2llr <- model$null.deviance - model$deviance
                cat(paste("      &", round(n2llr, digits)))
                gmdf <- model$df.null - model$df.residual + 1

                if (pchisq(n2llr, df = gmdf, lower.tail = FALSE) < alpha) {cat("*")}
            } else {
                cat("    &")
            }
            if (tight == FALSE) cat("     &")
        }
        cat("  \\\\\n")
    }

    ## Print a row for the model's fit, as -2 LLR
    ## Can't remember why I was multiplying by -2

    if (showAIC == TRUE) {
        cat(paste("$AIC$"),sep="")
        for (model in modelList) {
            cat(paste("      &", if(is.numeric(AIC(model)))round(AIC(model), digits)))
            if (tight == FALSE) cat("      &")
        }
        cat("  \\\\\n")
    }

    ## TODO: round the following output
    if (!missing(runFuns)){
        elist <- vector("list", length = length(runFuns))
        runFunsFn <- names(runFuns)
        for (i in 1:length(runFuns)){
            myfn <- runFunsFn[i]
            if (myfn == "logLik") {
                myresult <- lapply(modelList, function(x) {
                    y <- do.call(myfn, list(x))
                    fstaty <- paste(format(c(y), digits = digits), collapse = ", ",
                                        " (df=", format(attr(y, "df")), ")", sep = "")
                    invisible(fstaty)
                })
                elist[[i]] <- myresult
            } else {
                myresult <- lapply(modelList, function(x){
                    y <- do.call(myfn, list(x))
                    fstaty <- format(c(y), digits = digits, nsmall = 2 )
                })
                elist[[i]] <- myresult
            }
        }
        names(elist) <- runFunsFn

        for(i in 1:length(runFuns)){
            gofRow(elist[[i]], runFuns[i])
        }
    }

    cat("\\hline\\hline\n")
    cat(paste("* $p \\le", alpha, "$\n"))
    cat("\\end{tabular}\n")
    cat("\\end{center}\n")
    if (float == TRUE || !missing(title) || !missing(label)){
        cat("\\end{table}\n")
    }

}


outregText <-
    function(modelList, title, label, modelLabels = NULL,  varLabels = NULL,
             tight = TRUE, showAIC = FALSE, float = FALSE, request,
             runFuns, digits = 3, alpha = 0.05)
{
    ##Boiler plate names for GOF items
    gofNames <- c(N = "N", sigma = "RMSE", r.squared = "$R^2$",
                  deviance = "Deviance", adj.r.squared = "adj $R^2$",
                  fstatistic = "F")

    if (!missing(request)) gofNames <- c(gofNames, request)

    getBSE <- function(B, SE, PT, regname, modelname){
        est <- B[regname, modelname]
        se <- SE[regname, modelname]
        if (!is.na(est)) {
            sig <- if (PT[regname, modelname] < alpha) "*" else ""
        } else {
            est <- ""; se <- ""; sig <- "";
        }
        c(paste0(est,sig), se)
    }

    ## TESTME: grabs param from object by name, rounds, simplifies
    ## returns text. For getting r.square, adj.r.square, fstatistic.
    harvest <- function(sl, name) {
        res <- vector("character")
        namz <- names(sl)
        for(i in seq_along(sl)) {
            sli <- sl[[i]]
            y <- sli[[name]]
            if (!is.null(y) && name == "fstatistic"){
                staty <- paste(format(c(y["value"]), digits = digits),
                               " df(", format(y["numdf"], digits = digits),
                               ",", format(y["dendf"], digits = digits), ")", sep = "")
                y <- staty
            } else if (is.numeric(y)) {
                y <- round(y, digits)
            }
            if (!is.null(y)) res[namz[i]] <- y
        }
       attr(res, "nonNull") <- if (any(!is.na(res))) TRUE else FALSE
       res
    }

    gofPrint <- function(sl, name){
        y <- harvest(sl, name)
        newrow <- character(nColumns)
        names(newrow) <- colnamz
        newrow[1] <- ifelse(is.na(gofNames[name]), name, gofNames[name])
        newrow[names(y)] <- y
        newrow
    }


    ## was input just one model, or a list of models?  ###
    if (inherits(modelList, "lm")) { ##just one model input
        nmodels <- 1
        modelList <- list(modl1 = modelList)
    } else {
        modelList <- modelList
    }

    nmodels <- length(modelList)
    nColumns <- ifelse(tight, 1 + nmodels, 1 + 2 * nmodels)




    if (is.null(modelLabels)){
        ##Make temporary names
        modelLabels <- paste("M", 1:nmodels, sep ="")
        mln <- names(modelList)
        for (i in seq_along(mln)){
            modelLabels[i] <- mln[i]
        }
    }
    names(modelList) <- modelLabels

    colnamz <- vector("character", length = nColumns)

    colnamz[1] <- ""
    if (!tight){
        for (j in seq_along(modelLabels))
            colnamz[j * 2] <- modelLabels[j]
    } else {
        colnamz[2:nColumns] <- modelLabels

    }


    ## Get a regression summary object for each fitted model
    summaryList <- list()
    parmnames <- vector()
    myModelClass <- vector()

    for (i in seq_along(modelList)){
        model <- modelList[[i]]
        summaryList[[i]] <- ssm <- summary(model)
        parmnames <- unique(c(parmnames, names(coef(model))))
        myModelClass[i] <- class(model)[1]
        i <- i+1
    }

    summaryList <- lapply(modelList, function(x) tryCatch(summary(x), error = NULL))

    displayNames <-  as.character(parmnames)
    names(displayNames) <- as.character(parmnames)
    displayNames[names(varLabels)] <- varLabels

    B <- matrix(NA, nrow = length(parmnames), ncol =
                length(modelList), dimnames = list(parmnames))
    dimnames(B)[[2]] <- modelLabels

    SE <- matrix(NA, nrow = length(parmnames), ncol =
                 length(modelList), dimnames = list(parmnames))
    dimnames(SE)[[2]] <- modelLabels

    DF <- vector("numeric", length = nmodels)

    for(j in seq_along(modelList)){
        modl <- modelList[[j]]
        best <- coef(modl)
        B[parmnames, modelLabels[j]] <- best[parmnames]
        DF[j] <- modl$df.residual
        SE[parmnames, modelLabels[j]] <- sqrt(diag(vcov(modl)))[parmnames]
    }

    sigtest <- function(B, SE, DF) {
        PT <- matrix(NA, nrow = NROW(B), ncol =
                     NCOL(B), dimnames = dimnames(B))
        for (j in seq_along(DF)){
            PT[ ,j] <-  pt(abs((B/SE)[ ,j]), lower.tail = FALSE, df = DF[j]) *2
        }
        PT <- round(PT, digits)
        PT
    }
    PT <- sigtest(B, SE, DF)

    ##TODO. Look back later to consider generalizing so that we
    ## accept B, SE and PT from coef(summary) if it exists.

    B <- round(B, digits)
    SE <- round(SE, digits)
    SE <- apply(SE, c(1,2), function(x){ paste0("(",x,")") })



    ##pj ## If you want a LaTeX table float...
    ##pj if (float == TRUE || !missing(title) || !missing(label)){
    ##pj     cat("\\begin{table}\n")
    ##pj     if (missing(title)) title <- "A Regression"
    ##pj     if (missing(label)) label <- "regrlabl"
    ##pj     cat("\\caption{",title,"}\\label{",label,"}\n")
    ##pj }
    ##pj cat("\\begin{center}\n")
    ##pj cat(paste("\\begin{tabular}{*{",nColumns,"}{l}}\n", sep=""))
    ##pj cat("\\hline\n")

    ##pj ## Put model labels on top of each model column, if modelLabels were given
    ##pj if (!is.null(modelLabels)){
    ##pj     cat("     ")
    ##pj     for (modelLabel in modelLabels){
    ##pj         if (tight == TRUE) {
    ##pj             cat(paste("&", modelLabel))
    ##pj         }else{
    ##pj             cat(paste("&\\multicolumn{2}{c}{",modelLabel,"}",sep=""))
    ##pj         }
    ##pj     }
    ##pj     cat(" \\\\\n")
    ##pj }

    ## Print the headers "Estimate" and "(S.E.)", output depends on tight or other format
    ##pj if (tight == TRUE){
    ##pj     cat("               ", rep (" &Estimate ", nmodels), "\\\\\n")
    ##pj     cat("               ", rep (" &(S.E.) ", nmodels), "\\\\\n")
    ##pj } else {
    ##pj     cat("               ", rep (" &Estimate &(S.E.) ", nmodels), "\\\\\n", fill= FALSE)
    ##pj }
    ##pj cat("\\hline \n\\hline\n")

    if (tight){
        res1 <- c("           ", rep (c("Estimate"), nmodels))
        names(res1) <- colnamz
        res1 <- rbind(res1, c("           ", rep (c("(S.E.)"), nmodels)))
    } else {
        res1 <- c("           ", rep (c("Estimate", "(S.E.)"), nmodels))
        names(res1) <- "  "
        names(res1)[seq(2, nColumns, by = 2)] <- modelLabels
    }

    ## Here come the regression coefficients

    parmstruct <- list()
    for (regname in parmnames){
        XXX <- lapply(modelLabels, function(modnam) getBSE(B, SE, PT, regname, modnam))
        parmstruct[[regname]] <- if (tight) do.call("cbind", XXX)
        else do.call("cbind", lapply(XXX, t))
    }

    if (tight) {
        rownamz <- vector("character", length = length(parmnames) * 2)
        for (j in seq_along(parmnames)){
            rownamz[1 + (j-1)*2] <- parmnames[j]
            res2 <- do.call("rbind", parmstruct)
            res2 <- cbind(rownamz, res2)
        }
        colnames(res2) <- c("      ", modelLabels)
        rownames(res2) <- rownamz
    } else {
        res2 <- do.call("rbind", parmstruct)
        res2 <- cbind(parmnames, res2)
        colnames(res2) <- colnamz
        rownames(res2) <- parmnames
    }


    ### now list the gof we will try to print
    gof <- c("sigma", "r.squared", if (length(parmnames) > 1) "adj.r.squared", "deviance", if (!missing(request)) names(request))

    gof <- unique(gof)

    goflist <- lapply(gof, function(gname) gofPrint(summaryList, gname))
    names(goflist) <- gof

    sampSize <- character(length = nColumns)
    names(sampSize) <- colnamz
    sampSize[modelLabels] <- sapply(modelList, nobs)
    sampSize[1] <- "N"

    gofMat <- do.call("rbind", goflist)

    rbind(sampSize, gofMat)

    XX <-  list(header = res1, parms = res2, gof = gofMat)
    if (!missing(runFuns)) {
        runFunsFn <- names(runFuns)

        myresultlist <- list()
        for (i in 1:length(runFuns)) {

            myfn <- runFunsFn[i]

            if (myfn == "logLik") {
                myresultlist[[myfn]] <- lapply(modelList, function(x) {
                    y <- do.call(myfn, list(x))
                    fstaty <- paste(format(c(y), digits = digits), collapse = ", ",
                                    " (df=", format(attr(y, "df")), ")", sep = "")
                    invisible(fstaty)
                })
            } else {
                myresultlist[[myfn]] <- lapply(modelList, function(x){
                    y <- do.call(myfn, list(x))
                    fstaty <- format(c(y), digits = digits, nsmall = 2 )
                })
                names(myresultlist[[myfn]]) <- modelLabels
            }
        }

        ## assemble those into matrix using stupidest possible way
        res4 <- matrix("", nrow = length(runFuns), ncol = length(colnamz),
                       dimnames = list(runFunsFn, colnamz))

        myresultlistnamz <- names(myresultlist)
        for (i in seq_along(myresultlist)){
            onerow <- myresultlist[[i]]
            onerownamz <- names(onerow)
            for (j in seq_along(onerow)) {
                res4[myresultlistnamz[i] ,onerownamz[j]] <- onerow[[onerownamz[j]]]
            }
        }
        res4[ , 1] <- runFuns
        XX[["res4"]] <- res4
    }
    XXX <- do.call("rbind", XX)
    row.names(XXX) <- NULL
    noquote(XXX)
}


##     ## Print a row for the model's fit, as -2LLR
##     if ("glm" %in% myModelClass) {
##         cat(paste("$-2LLR (Model \\chi^2)$"),sep="")
##         for (model in modelList) {
##             if (is.numeric(model$deviance)){
##                 n2llr <- model$null.deviance - model$deviance
##                 cat(paste("      &", round(n2llr, digits)))
##                 gmdf <- model$df.null - model$df.residual + 1

##                 if (pchisq(n2llr, df = gmdf, lower.tail = FALSE) < alpha) {cat("*")}
##             } else {
##                 cat("    &")
##             }
##             if (tight == FALSE) cat("     &")
##         }
##         cat("  \\\\\n")
##     }

##     cat("\\hline\\hline\n")
##     cat(paste("* $p \\le", alpha, "$\n"))
##     cat("\\end{tabular}\n")
##     cat("\\end{center}\n")
##     if (float == TRUE || !missing(title) || !missing(label)){
##         cat("\\end{table}\n")
##     }

## }

